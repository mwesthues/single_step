# Transformed Kernels
```{r setup-kernel-transformation, message = FALSE, echo = FALSE}
if (!require("pacman")) install.packages("pacman")
if (!require("devtools")) install.packages("devtools")
devtools::install_github("mwesthues/sspredr", update = TRUE)
pacman::p_load("BGLR","data.table", "tidyverse", "dtplyr", "caret", "e1071",
               "stringr")
pacman::p_load_gh("mwesthues/sspredr")

knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",", digits = 2)
})
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(fig.width = 8, fig.height = 6,
                      warning = FALSE, echo = FALSE)
```


After noticing extremely narrow distributions in the coefficients of 
$\mathbf{W}$ (defined in Eq. \@ref(eq:mrna-model), Fig.
\@ref(fig:Plot-kernel-coefficients)), we decided to explore the effect of several
data pre-processing procedures on the distribution of the coefficients.
Separately for each heterotic group, the following data pre-processing 
procedures were applied to the transcriptomic data: i) Box-Cox transformation,
ii) centering, iii) scaling, removal of features with a correlation 
$\rho \geq 0.999$, using the function `preProcess` from the R package `caret` 
[@Kuhn2013].
Separately for each heterotic group and each subset of features (i.e. `snp100`, 
`snp77` and `snp42`), only SNPs that were not in perfect linkage disequilibrium
with another marker were kept. 
From Fig. \@ref(fig:Plot-transformed-kernel-coefficients) we can glean that 
data processing had a considerable, positive effect on the distribution of 
coefficients in $\mathbf{W}$, which became wider in the case of predictor 
combinations such as `ped100_snp77_mrna42` compared to unprocessed features 
(Fig \@ref(fig:Plot-kernel-coefficients)).

```{r Raw-Kernel-Transformation, cache = TRUE}
genos <- readRDS("./data/processed/common_genotypes.RDS")
cat_lst <- readRDS("./data/derived/pred_sub_list.RDS")

mrna_inbreds <- genos %>%
  filter(Pool != "Hybrid", Data_Type == "mrna") %>%
  split(.$Pool) %>%
  map("G")

# mRNA
mrna <- readRDS("./data/processed/subset_mrna_blues.RDS")[["100%"]]
mrna <- t(mrna)
mrna <- mrna[grep("Exp|Sigma", x = rownames(mrna), invert = TRUE), ]
mrna_df <- mrna %>%
  as_data_frame() %>%
  mutate(G = rownames(mrna)) %>%
  mutate(Group = ifelse(G %in% mrna_inbreds$Dent, yes = "Dent", no = "Flint"),
         Group = as.factor(Group))

## Data pre-processing
# Pre-process the data in the following order:
# 1.    Box-Cox tranformation
# 2.    Centering
# 3.    Scaling
# 4.    Remove highly correlated features
mrna_lst <- mrna_df %>% 
  split(.$Group) %>%
  map(as.data.frame) %>%
  map(~column_to_rownames(., var = "G")) %>%
  map(.f = function(x) {
    x$Group <- NULL
    x
  }) %>%
  map(~as.matrix(.))

# Data transformation
trans_lst <- mrna_lst %>%
  map(preProcess,
      method = c("BoxCox", "center", "scale")) %>%
  map2(.y = mrna_lst, .f = predict)

mrna_cor_idx <- trans_lst %>%
  map(cor) %>%
  map(~findCorrelation(x = ., cutoff = 0.999))

mrna42 <- lapply(seq_along(trans_lst), FUN = function(i) {
  mat <- trans_lst[[i]]
  high_cor_idx <- mrna_cor_idx[[i]]
  if (isTRUE(length(high_cor_idx) != 0)) {
    mat <- mat[, -high_cor_idx]
  }
  mat
})
names(mrna42) <- names(mrna_lst)

# Remove perfect LD
snp42 <- cat_lst %>% 
  transpose() %>%
  .[names(.) == "snp42"] %>%
  at_depth(.depth = 2, .f = 1) %>%
  .[[1]]

snp77 <- cat_lst %>% 
  transpose() %>%
  .[names(.) == "ped100_snp77"] %>%
  at_depth(.depth = 2, .f = 2) %>%
  .[[1]]

snp100 <- cat_lst %>%
  transpose() %>%
  .[names(.) == "snp100"] %>%
  at_depth(.depth = 2, .f = 1) %>%
  .[[1]]

snp_lst <- list(snp100 = snp100, snp77 = snp77, snp42 = snp42)
snp_lst[] <- lapply(snp_lst , FUN = function(x) {
  thinned_snp <- x %>%
    map(unique, MARGIN = 2)
  names(thinned_snp) <- c("Dent", "Flint")
  thinned_snp
})
invisible(list2env(snp_lst, envir = globalenv()))

# Get pedigree data
ped100 <- cat_lst %>% 
  transpose() %>%
  .[names(.) == "ped100_snp77"] %>%
  at_depth(.depth = 2, .f = 1) %>%
  .[[1]]
names(ped100) <- c("Dent", "Flint")

ped42 <- cat_lst %>% 
  transpose() %>%
  .[names(.) == "ped42"] %>%
  at_depth(.depth = 2, .f = 1) %>%
  .[[1]]
names(ped42) <- c("Dent", "Flint")
```



```{r Kernel-assembly, cache = TRUE}
nms100 <- cat_lst %>%
  transpose() %>%
  .[names(.) == "ped100"] %>%
  at_depth(.depth = 2, "geno") %>%
  .[[1]]

nms42 <- cat_lst %>%
  transpose() %>%
  .[names(.) == "mrna42"] %>%
  at_depth(.depth = 2, "geno") %>%
  .[[1]]

# Specify the predictor sets.
pred_sets <- c(
  "snp42", "mrna42", "snp100", "ped100-snp77", "ped100-mrna42",
  "snp100-mrna42", "ped100-snp77-mrna42"
  ) %>%
  strsplit(., split = "[-]")

trans_cat_lst <- lapply(pred_sets, FUN = function(x) {
  cmb_lst <- x %>% 
    map(~get(.))
  names(cmb_lst) <- x
  cmb_lst <- cmb_lst %>% 
    transpose()
  largest_pred_size <- x %>%
    str_extract(., pattern = "[0-9]+") %>%
    as.integer() %>% 
    max()

  if (isTRUE(largest_pred_size == 100)) {
    hyb_names_pred_size <- nms100
  } else {
    hyb_names_pred_size <- nms42
  }
  names(hyb_names_pred_size) <- c("Dent", "Flint")

  cmb_lst[] <- lapply(seq_along(cmb_lst), FUN = function(i) {
    nm <- names(cmb_lst)[i]
    dat <- cmb_lst[[nm]]
    dat$geno <- hyb_names_pred_size[[nm]]
    dat
  })
  cmb_lst
})
names(trans_cat_lst) <- pred_sets %>%
  map(~paste(., collapse = "_")) %>%
  flatten_chr()
trans_cat_lst <- trans_cat_lst %>%
  transpose()
saveRDS(trans_cat_lst, 
        file = "./data/derived/transformed_pred_sub_list.RDS")

## -- BUILD KERNELS --------------------------------------------------------
# Apply kernel building functions to different predictor sets.
# The choice of function depends on the number of predictors as well as on the
# type of predictor (are pedigree data involved or not?).
ped100_snp77_mrna42 <- trans_cat_lst %>%
  transpose() %>%
  .[["ped100_snp77_mrna42"]] %>%
  map(~impute2(ped = .[[1]],
               snp = .[[2]],
               mrna = .[[3]],
               geno = .[["geno"]],
               as_kernel = TRUE,
               bglr_model = "BRR"
    )
  ) %>%
  map(2) %>%
  map("X")

snp100_mrna42 <- trans_cat_lst %>%
  transpose() %>%
  .[["snp100_mrna42"]] %>%
  map(~impute_eta(
     x = .[[1]],
     y = .[[2]],
     geno = .[["geno"]],
     as_kernel = TRUE,
     is_pedigree = FALSE,
     bglr_model = "BRR"
    )
  ) %>%
  map(2) %>%
  map("X")

ped100_x <- trans_cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("ped100_mrna42", "ped100_snp77")] %>%
  at_depth(.depth = 2, .f = ~impute_eta(
    x = .[[1]],
    y = .[[2]],
    geno = .[["geno"]], 
    as_kernel = TRUE,
    is_pedigree = TRUE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 2) %>%
  at_depth(.depth = 2, .f = "X")

single_pred <- trans_cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("snp42", "mrna42", "snp100")] %>%
  at_depth(.depth = 2, .f = ~complete_eta(
    x = .[[1]],
    geno = .[["geno"]],
    as_kernel = TRUE,
    is_pedigree = FALSE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 1) %>%
  at_depth(.depth = 2, .f = "X")
    
# Combine the results in a single list to reduce code replications (the
# following steps are the same for all predictor sets).
W_lst <- c(list(ped100_snp77_mrna42 = ped100_snp77_mrna42),
           list(snp100_mrna42 = snp100_mrna42),
           ped100_x,
           single_pred)
```

```{r Plot-transformed-kernel-coefficients, cache = TRUE, fig.cap = "Distribution of coefficients that are elements of the transformed kernel matrices $\\mathbf{W}$ used in single step or regular prediction of hybrid performance."}
## -- PLOT KERNEL COEFFICIENTS ---------------------------------------------
# Extract the coefficients from the lower triangle of the kernels for
# subsequent plotting of their distributions.
W_df <- W_lst %>%
  at_depth(.depth = 2, .f = ~.[match(colnames(.), rownames(.)), ]) %>%
  at_depth(.depth = 2, .f = ~.[lower.tri(., diag = FALSE)]) %>%
  map(function(x) {
    names(x) <- c("Dent", "Flint")
    x 
  }) %>%
  map(.f = stack) %>%
  bind_rows(.id = "id") %>%
  rename(Predictor = id, 
         Values = values,
         Group = ind) %>%
  as_tibble()

# For each predictor set and each heterotic group, plot the distribution of the
# coefficients from the kernels.
W_df %>%
  ggplot(aes(x = Values, fill = Group)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 80) +
  facet_wrap(~ Predictor, scales = "free") +
  theme_bw() +
  theme(legend.position = "top") +
  scale_fill_manual(values = c("#669933", "#FFCC66")) +
  xlim(c(-1.0, 1.0))
```
