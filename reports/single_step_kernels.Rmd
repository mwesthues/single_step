# Kernel Inspection
```{r setup-kernel-inspection, message = FALSE, echo = FALSE}
if (!require("pacman")) install.packages("pacman")
if (!require("devtools")) install.packages("devtools")
devtools::install_github("mwesthues/sspredr", update = TRUE)
pacman::p_load("BGLR","data.table", "parallel", "magrittr", "dplyr", "tidyr",
               "purrr", "testthat", "methods", "tibble", "ggplot2", "stringr",
               "stringi", "lubridate", "readr")
pacman::p_load_gh("mwesthues/sspredr")

knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",", digits = 2)
})
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(fig.width = 8, fig.height = 6,
                      warning = FALSE, echo = FALSE)
```

Goal: Inspection of input matrices for single-step hybrid prediction using 
BGLR.

```{r Prepare-Kernel-Inspection, cache = TRUE}
## -- DATA SELECTION -----------------------------------------------------
# Specify the predictor sets.
preds <- c("ped42-none-none", "snp42-none-none", "mrna42-none-none",
           "ped100-none-none", "snp100-none-none", "ped100-snp77-none",
           "ped100-mrna42-none", "snp100-mrna42-none", "ped100-snp77-mrna42")

# Load the predictor data.
pred_lst <- preds %>%
  as.list() %>%
  map(~str_split(string = ., pattern = "-")) %>%
  at_depth(.depth = 2, ~discard(., . == "none")) %>%
  at_depth(.depth = 2, as.list) %>%
  at_depth(.depth = 2, 
           .f = ~paste0("./data/derived/predictor_subsets/", ., ".RDS")) %>%
  at_depth(.depth = 3, .f = readRDS) %>%
  flatten()
names(pred_lst) <- preds

# For each predictor set and for each heterotic group, select the corresponding
# hybrids for which phenotpyic data are available.
# Then, store the names of all Dent and Flint hybrid parents in a list in order 
# to correctly augment the predictor matrices with their help.
genos <- readRDS("./data/processed/common_genotypes.RDS")
hybrid <- genos %>%
  filter(Pool == "Hybrid") %>%
  mutate(G = stringr::str_replace(G, pattern = "DF_", replacement = "")) %>%
  separate(G, into = c("Dent", "Flint"), sep = "_")
geno_nms <- pred_lst %>%
  at_depth(.depth = 2, .f = rownames) %>%
  map(.f = ~reduce(., union))
hybrid_parent_nms <- lapply(seq_along(geno_nms), FUN = function(i) {
  ind_nms <- geno_nms[[i]] 
  hybrid %>%
    filter(Dent %in% ind_nms, Flint %in% ind_nms) %>%
    unite(col = Hybrid, Dent, Flint, sep = "_", remove = FALSE) %>%
    mutate(Hybrid = paste0("DF_", Hybrid)) %>%
    gather(key = "Group", value = "G", Dent, Flint) %>%
    split(.$Group) %>%
    map("G")
})
names(hybrid_parent_nms) <- names(pred_lst)
hybrid_parent_nms <- transpose(hybrid_parent_nms)


## -- PREPARE DATA FOR KERNEL BUILDING ------------------------------------
# Split the predictor matrices into Dent and Flint.
# Then, transform the data frames back to matrices in order to be able build 
# kernels from them.
merge_pred <- function(x, genos) {
  y <- genos %>%
    select(G, Pool) %>%
    distinct(G, .keep_all = TRUE)
  x %>%
    as.data.frame() %>%
    rownames_to_column(., var = "G") %>%
    as_tibble() %>%
    left_join(., y = y, by = "G") %>%
    split(., .$Pool)
}
pred_df_to_matrix <- function(x) {
  x %>%
    select(-Pool) %>%
    as.data.frame() %>%
    column_to_rownames(var = "G") %>%
    as.matrix()
}
feat_lst <- pred_lst %>%
  at_depth(.depth = 2,
           .f = merge_pred, genos = genos) %>%
  map(transpose) %>%
  at_depth(.depth = 3, .f = pred_df_to_matrix)
names(feat_lst) <- str_replace_all(preds, pattern = "-", replacement = "_")
feat_lst <- transpose(feat_lst)

# As a requirement of the kernel-generating functions, add the names of the 
# hybrid parents to each predictor-set/group combination.
cat_lst <- lapply(seq_along(feat_lst), FUN = function(i) {
  x_lvl1 <- feat_lst[[i]] 
  y_lvl1 <- hybrid_parent_nms[[i]]
  geno_lst <- lapply(seq_along(x_lvl1), FUN = function(j) {
    x_lvl2 <- x_lvl1[[j]]
    y_lvl2 <- y_lvl1[[j]]
    x_lvl2[["geno"]] <- y_lvl2
    x_lvl2
  })
  names(geno_lst) <- names(x_lvl1)
  geno_lst
})
saveRDS(cat_lst,
        file = "./data/derived/pred_sub_list.RDS")


## -- BUILD KERNELS --------------------------------------------------------
# Apply kernel building functions to different predictor sets.
# The choice of function depends on the number of predictors as well as on the
# type of predictor (are pedigree data involved or not?).
ped100_snp77_mrna42 <- cat_lst %>%
  transpose() %>%
  .[["ped100_snp77_mrna42"]] %>%
  map(~impute2(ped = .[[1]],
               snp = .[[2]],
               mrna = .[[3]],
               geno = .[["geno"]],
               as_kernel = TRUE,
               bglr_model = "BRR"
    )
  ) %>%
  map(2) %>%
  map("X")

snp100_mrna42_none <- cat_lst %>%
  transpose() %>%
  .[["snp100_mrna42_none"]] %>%
  map(~impute_eta(
     x = .[[1]],
     y = .[[2]],
     geno = .[["geno"]],
     as_kernel = TRUE,
     is_pedigree = FALSE,
     bglr_model = "BRR"
    )
  ) %>%
  map(2) %>%
  map("X")

ped100_x_none <- cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("ped100_mrna42_none", "ped100_snp77_none")] %>%
  at_depth(.depth = 2, .f = ~impute_eta(
    x = .[[1]],
    y = .[[2]],
    geno = .[["geno"]], 
    as_kernel = TRUE,
    is_pedigree = TRUE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 2) %>%
  at_depth(.depth = 2, .f = "X")

pedx_none_none <- cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("ped100_none_none", "ped42_none_none")] %>%
  at_depth(.depth = 2, .f = ~complete_eta(
    x = .[[1]],
    geno = .[["geno"]],
    as_kernel = FALSE,
    is_pedigree = TRUE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 1) %>%
  at_depth(.depth = 2, .f = "X")

single_pred <- cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("snp42_none_none", "mrna42_none_none", 
                    "snp100_none_none")] %>%
  at_depth(.depth = 2, .f = ~complete_eta(
    x = .[[1]],
    geno = .[["geno"]],
    as_kernel = TRUE,
    is_pedigree = FALSE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 1) %>%
  at_depth(.depth = 2, .f = "X")
    
# Combine the results in a single list to reduce code replications (the
# following steps are the same for all predictor sets).
W_lst <- c(list(ped100_snp77_mrna42 = ped100_snp77_mrna42),
           list(snp100_mrna42_none = snp100_mrna42_none),
           pedx_none_none,
           ped100_x_none,
           single_pred)
```


```{r Plot-kernel-coefficients, cache = TRUE, fig.cap = "Distribution of coefficients that are elements of the kernel matrices used in single step or regular prediction of hybrid performance."}
## -- PLOT KERNEL COEFFICIENTS ---------------------------------------------
# Extract the coefficients from the lower triangle of the kernels for
# subsequent plotting of their distributions.
W_df <- W_lst %>%
  at_depth(.depth = 2, .f = ~.[match(colnames(.), rownames(.)), ]) %>%
  at_depth(.depth = 2, .f = ~.[lower.tri(., diag = FALSE)]) %>%
  map(function(x) {
    names(x) <- c("Dent", "Flint")
    x 
  }) %>%
  map(.f = stack) %>%
  bind_rows(.id = "id") %>%
  rename(Predictor = id, 
         Values = values,
         Group = ind) %>%
  as_tibble()

# For each predictor set and each heterotic group, plot the distribution of the
# coefficients from the kernels.
W_df %>%
  ggplot(aes(x = Values, fill = Group)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 80) +
  facet_wrap(~ Predictor, scales = "free") +
  theme_bw() +
  theme(legend.position = "top") +
  scale_fill_manual(values = c("#669933", "#FFCC66")) +
  xlim(c(-1.0, 1.0))
```

```{r Extreme-Kernel-Coefficients, cache = TRUE}
extreme_cap <- paste("Most extreme values for each predictor set and each", 
                     "heterotic group.")
W_df %>%
  group_by(Predictor) %>%
  summarize(Min = round(min(Values), digits = 3),
            Max = round(max(Values), digits = 3)) %>%
  ungroup() %>%
  knitr::kable(caption = extreme_cap, booktabs = TRUE)
```


```{r Kernel-Closeup, cache = TRUE, fig.cap = "Distribution of kernel coefficients used in single step hybrid prediction for a scenario with complete genomic and incomplete transcriptomic information ('snp100-mrna42-none') as well as a scenario with complete pedigree, incomplete genomic and incomplete transcriptomic information ('ped100-snp77-mrna42'). The focus was placed on coefficients in the range from -0.1 to +0.1."}
W_df %>%
  filter(Predictor %in% c("snp100_mrna42_none", "ped100_snp77_mrna42")) %>%
  ggplot(aes(x = Values, fill = Group)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 80) +
  facet_wrap(~ Predictor, scales = "free") +
  theme_bw() +
  theme(legend.position = "top") +
  scale_fill_manual(values = c("#669933", "#FFCC66")) +
  xlim(c(-0.1, 0.1))
```

