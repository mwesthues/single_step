# Original Kernels
```{r setup-kernel-inspection, message = FALSE, echo = FALSE}
if (!require("pacman")) install.packages("pacman")
if (!require("devtools")) install.packages("devtools")
devtools::install_github("mwesthues/sspredr", update = TRUE)
pacman::p_load("BGLR","data.table", "tidyverse", "dtplyr", "caret", "e1071",
               "stringr")
pacman::p_load_gh("mwesthues/sspredr")

knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",", digits = 2)
})
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(fig.width = 8, fig.height = 6,
                      warning = FALSE, echo = FALSE)
```

With the original configuration of the predictors, very low predictive abilities
were obtained for the amalgamation of pedigree, genomic and transcriptomic 
information, regardless of the phenotypic trait.
One of the possible causes were inconsistencies in the functions `impute_eta()`
and `impute2` from the `sspredr` package regarding the factorization of 
matrices.
After tackling those bugs, we wanted to revisit the distribution of the 
coefficients from the matrix $\mathbf{W}$ in \@ref(eq:mrna-model).

```{r Prepare-Kernel-Inspection, cache = TRUE}
## -- DATA SELECTION -----------------------------------------------------
# Specify the predictor sets.
preds <- c("ped42-none-none", "snp42-none-none", "mrna42-none-none",
           "ped100-none-none", "snp100-none-none", "ped100-snp77-none",
           "ped100-mrna42-none", "snp100-mrna42-none", "ped100-snp77-mrna42")

# Load the predictor data.
pred_lst <- preds %>%
  as.list() %>%
  map(~str_split(string = ., pattern = "-")) %>%
  at_depth(.depth = 2, ~discard(., . == "none")) %>%
  at_depth(.depth = 2, as.list) %>%
  at_depth(.depth = 2, 
           .f = ~paste0("./data/derived/predictor_subsets/", ., ".RDS")) %>%
  at_depth(.depth = 3, .f = readRDS) %>%
  flatten()
names(pred_lst) <- preds

# For each predictor set and for each heterotic group, select the corresponding
# hybrids for which phenotpyic data are available.
# Then, store the names of all Dent and Flint hybrid parents in a list in order 
# to correctly augment the predictor matrices with their help.
genos <- readRDS("./data/processed/common_genotypes.RDS")
hybrid <- genos %>%
  filter(Pool == "Hybrid") %>%
  mutate(G = stringr::str_replace(G, pattern = "DF_", replacement = "")) %>%
  separate(G, into = c("Dent", "Flint"), sep = "_")
geno_nms <- pred_lst %>%
  at_depth(.depth = 2, .f = rownames) %>%
  map(.f = ~reduce(., union))
hybrid_parent_nms <- lapply(seq_along(geno_nms), FUN = function(i) {
  ind_nms <- geno_nms[[i]] 
  hybrid %>%
    filter(Dent %in% ind_nms, Flint %in% ind_nms) %>%
    unite(col = Hybrid, Dent, Flint, sep = "_", remove = FALSE) %>%
    mutate(Hybrid = paste0("DF_", Hybrid)) %>%
    gather(key = "Group", value = "G", Dent, Flint) %>%
    split(.$Group) %>%
    map("G")
})
names(hybrid_parent_nms) <- names(pred_lst)
hybrid_parent_nms <- transpose(hybrid_parent_nms)


## -- PREPARE DATA FOR KERNEL BUILDING ------------------------------------
# Split the predictor matrices into Dent and Flint.
# Then, transform the data frames back to matrices in order to be able build 
# kernels from them.
merge_pred <- function(x, genos) {
  y <- genos %>%
    select(G, Pool) %>%
    distinct(G, .keep_all = TRUE)
  x %>%
    as.data.frame() %>%
    rownames_to_column(., var = "G") %>%
    as_tibble() %>%
    left_join(., y = y, by = "G") %>%
    split(., .$Pool)
}
pred_df_to_matrix <- function(x) {
  x %>%
    select(-Pool) %>%
    as.data.frame() %>%
    column_to_rownames(var = "G") %>%
    as.matrix()
}
feat_lst <- pred_lst %>%
  at_depth(.depth = 2,
           .f = merge_pred, genos = genos) %>%
  map(transpose) %>%
  at_depth(.depth = 3, .f = pred_df_to_matrix)
names(feat_lst) <- str_replace_all(preds, pattern = "-", replacement = "_")
feat_lst <- transpose(feat_lst)

# As a requirement of the kernel-generating functions, add the names of the 
# hybrid parents to each predictor-set/group combination.
cat_lst <- lapply(seq_along(feat_lst), FUN = function(i) {
  x_lvl1 <- feat_lst[[i]] 
  y_lvl1 <- hybrid_parent_nms[[i]]
  geno_lst <- lapply(seq_along(x_lvl1), FUN = function(j) {
    x_lvl2 <- x_lvl1[[j]]
    y_lvl2 <- y_lvl1[[j]]
    x_lvl2[["geno"]] <- y_lvl2
    x_lvl2
  })
  names(geno_lst) <- names(x_lvl1)
  geno_lst
})
names(cat_lst) <- names(feat_lst)

# Remove empty names (i.e. 'none') from predictor set names.
cat_lst <- cat_lst %>%
  map(function(x) {
    names(x) <- str_replace_all(names(x), pattern = "_none", replacement = "")
    x
  })
saveRDS(cat_lst,
        file = "./data/derived/pred_sub_list.RDS")


## -- BUILD KERNELS --------------------------------------------------------
# Apply kernel building functions to different predictor sets.
# The choice of function depends on the number of predictors as well as on the
# type of predictor (are pedigree data involved or not?).
ped100_snp77_mrna42 <- cat_lst %>%
  transpose() %>%
  .[["ped100_snp77_mrna42"]] %>%
  map(~impute2(ped = .[[1]],
               snp = .[[2]],
               mrna = .[[3]],
               geno = .[["geno"]],
               as_kernel = TRUE,
               bglr_model = "BRR"
    )
  ) %>%
  map(2) %>%
  map("X")

snp100_mrna42 <- cat_lst %>%
  transpose() %>%
  .[["snp100_mrna42"]] %>%
  map(~impute_eta(
     x = .[[1]],
     y = .[[2]],
     geno = .[["geno"]],
     as_kernel = TRUE,
     is_pedigree = FALSE,
     bglr_model = "BRR"
    )
  ) %>%
  map(2) %>%
  map("X")

ped100_x <- cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("ped100_mrna42", "ped100_snp77")] %>%
  at_depth(.depth = 2, .f = ~impute_eta(
    x = .[[1]],
    y = .[[2]],
    geno = .[["geno"]], 
    as_kernel = TRUE,
    is_pedigree = TRUE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 2) %>%
  at_depth(.depth = 2, .f = "X")

pedx <- cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("ped100", "ped42")] %>%
  at_depth(.depth = 2, .f = ~complete_eta(
    x = .[[1]],
    geno = .[["geno"]],
    as_kernel = FALSE,
    is_pedigree = TRUE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 1) %>%
  at_depth(.depth = 2, .f = "X")

single_pred <- cat_lst %>%
  transpose() %>%
  .[names(.) %in% c("snp42", "mrna42", "snp100")] %>%
  at_depth(.depth = 2, .f = ~complete_eta(
    x = .[[1]],
    geno = .[["geno"]],
    as_kernel = TRUE,
    is_pedigree = FALSE,
    bglr_model = "BRR"
    )
  ) %>%
  at_depth(.depth = 2, .f = 1) %>%
  at_depth(.depth = 2, .f = "X")
    
# Combine the results in a single list to reduce code replications (the
# following steps are the same for all predictor sets).
W_lst <- c(list(ped100_snp77_mrna42 = ped100_snp77_mrna42),
           list(snp100_mrna42 = snp100_mrna42),
           pedx,
           ped100_x,
           single_pred)
```


```{r Plot-kernel-coefficients, cache = TRUE, fig.cap = "Distribution of coefficients that are elements of the unmodified kernel matrices ($\\mathbf{W}$) used in single step or regular prediction of hybrid performance."}
## -- PLOT KERNEL COEFFICIENTS ---------------------------------------------
# Extract the coefficients from the lower triangle of the kernels for
# subsequent plotting of their distributions.
W_df <- W_lst %>%
  at_depth(.depth = 2, .f = ~.[match(colnames(.), rownames(.)), ]) %>%
  at_depth(.depth = 2, .f = ~.[lower.tri(., diag = FALSE)]) %>%
  map(function(x) {
    names(x) <- c("Dent", "Flint")
    x 
  }) %>%
  map(.f = stack) %>%
  bind_rows(.id = "id") %>%
  rename(Predictor = id, 
         Values = values,
         Group = ind) %>%
  as_tibble()

# For each predictor set and each heterotic group, plot the distribution of the
# coefficients from the kernels.
W_df %>%
  ggplot(aes(x = Values, fill = Group)) +
  geom_histogram(alpha = 0.5, position = "identity", bins = 80) +
  facet_wrap(~ Predictor, scales = "free") +
  theme_bw() +
  theme(legend.position = "top") +
  scale_fill_manual(values = c("#669933", "#FFCC66")) +
  xlim(c(-1.0, 1.0))
```


