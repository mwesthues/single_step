# Genotype-Wise mRNA-Imputation
```{r echo = FALSE}
pacman::p_load("sspredr", "tidyverse", "caret", "e1071", "viridis")
knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",", small.mark = ".", digits = 2)
})
knitr::opts_knit$set(root.dir = "~/gamazon/", inline = TRUE)
knitr::opts_chunk$set(fig.width = 8, fig.height = 6, 
                      warning = FALSE, message = FALSE)
```



```{r Predictor-Data, cache = TRUE}
# Common genotypes
genos <- readRDS("./data/processed/common_genotypes.RDS")
dent <- as.character(genos$Dent$mrna)
flint <- as.character(genos$Flint$mrna)

# Remove the 'Group' variable after splitting Dent and Flint data.
rm_grp <- function(x) {
  x$Group <- NULL
  x
}

# mRNA
mrna <- readRDS("./data/processed/subset_mrna_blues.RDS")[["100%"]]
mrna <- t(mrna)
mrna <- mrna[grep("Exp|Sigma", x = rownames(mrna), invert = TRUE), ]
mrna_lst <- mrna %>%
  as_data_frame() %>%
  mutate(G = rownames(mrna)) %>%
  mutate(Group = ifelse(G %in% dent, yes = "Dent", no = "Flint"),
         Group = as.factor(Group)) %>%
  as.data.frame() %>%
  column_to_rownames(var = "G") %>%
  split(.$Group) %>%
  map(rm_grp) %>%
  map(~as.matrix(.))

# SNPs
snp <- readRDS("./data/processed/snp_mat.RDS")
snp_lst <- snp %>%
  as_data_frame() %>%
  mutate(G = rownames(snp)) %>%
  filter(G %in% c(dent, flint)) %>%
  mutate(Group = ifelse(G %in% dent, yes = "Dent", no = "Flint"),
         Group = as.factor(Group)) %>%
  as.data.frame() %>%
  column_to_rownames(var = "G") %>%
  split(.$Group) %>%
  map(rm_grp) %>%
  map(~as.matrix(.))
```



## Function for the imputation of a single mRNA.
```{r Impute-mRNA-Function}
## Function for the imputation of a single mRNA
impute_mrna_genotype <- function(x, y) {
  geno <- rownames(x)
  # Names of genotypes for which transcriptomic records exist
  nm2 <- rownames(y)
  # Names of genotypes for which transcriptomic records are missing.
  nm1 <- setdiff(rownames(x), nm2)
  # Hybrid parents not in y.
  geno1 <- geno[geno %in% nm1]
  # Hybrid parents in y.
  geno2 <- geno[geno %in% nm2]
  x <- x[match(unique(geno), rownames(x)), ]
  # Design matrix mapping GCA effects from genotypes with transcriptomic
  # records to y2.
  Z2 <- Matrix::sparse.model.matrix(~-1 + factor(geno2),
                                    drop.unused.levels = FALSE)
  colnames(Z2) <- gsub("factor\\(geno2\\)", replacement = "", x = colnames(Z2))
  Z2 <- Z2[, match(nm2, colnames(Z2))]
  rownames(Z2) <- geno2
  # Hybrid parents not in y.
  geno1 <- geno[geno %in% nm1]
  # Hybrid parents in y.
  geno2 <- geno[geno %in% nm2]
  x <- x[match(unique(geno), rownames(x)), ]
  y <- y[nm2, ]
  M2 <- y[, matrixStats::colVars(y) != 0]
  x <- x[, matrixStats::colVars(x) != 0]
  A <- build_kernel(M = x, lambda = 0.01, algorithm = "RadenII")
  A11 <- A[nm1, nm1, drop = FALSE]
  A12 <- A[nm1, nm2, drop = FALSE]
  A21 <- A[nm2, nm1, drop = FALSE]
  A22 <- A[nm2, nm2, drop = FALSE]
  Ainv <- solve(A)
  dimnames(Ainv) <- dimnames(A)
  A_up11 <- Ainv[nm1, nm1]
  A_up12 <- Ainv[nm1, nm2]
  # Eq.21
  M1 <- A12 %*% solve(A22) %*% M2
  J2 <- matrix(-1, nrow = ncol(A12), ncol = 1)
  # Eq.22
  J1 <- A12 %*% solve(A22) %*% J2
  # Eq.10
  epsilon <- t(chol(solve(Ainv[nm1, nm1])))
  # Eq.20
  W2 <- Z2 %*% M2
  w1 <- A12 %*% solve(A22) %*% Z2 %*% M2
  as.numeric(w1)
}
```


## Correlations between vectors of original and imputed mRNAs.
```{r Compute-Correlation-Imputed-vs-NonImputed, cache = TRUE}
# Wrapper function for the imputation of single genotypes.
imp_loop <- function(x, y) {
  vapply(seq_len(nrow(y)), FUN = function(i) {
    z <- y[-i, ]
    imp_mrna <- impute_mrna_genotype(x = x, y = z)
    cor(y[i, ], imp_mrna)
  }, FUN.VALUE = numeric(1))
}
# Separately for each heterotic group, compute the correlation between each 
# original mRNA-genotype and the corresponding imputed mRNA-genotype.
imp_correlations <- map2(.x = snp_lst, .y = mrna_lst, .f = imp_loop)
```


```{r Plot-Correlation-Imputed-vs-NonImputed, cache = TRUE, fig.cap = "Distribution of Pearson correlation coefficients between original and imputed mRNA genotypes for two heterotic groups."}
# Plot the distribution of the resulting Pearson correlation coefficients.
imp_correlations %>%
  stack() %>%
  rename(Value = values,
         Group = ind) %>%
  ggplot(aes(x = Value)) +
  geom_density() +
  geom_rug() +
  facet_grid(. ~ Group) +
  ylab("Density")
```





















