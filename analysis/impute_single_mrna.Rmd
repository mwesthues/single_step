---
title: "Genotype-Wise mRNA-Imputation"
author: Matthias Westhues
date: "`r Sys.Date()`"
output: 
  html_document:
    theme: united
    highlight: tango
    toc: true
    toc_float: true
---

Keep only genotypes for which both, transcriptomic and genomic data are 
available.
```{r}
pacman::p_load("sspredr", "tidyverse", "caret", "e1071", "viridis")
knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",", digits = 2)
})
knitr::opts_knit$set(root.dir = "~/gamazon/", inline = TRUE)
knitr::opts_chunk$set(fig.width = 8, fig.height = 6, 
                      warning = FALSE, message = FALSE)
```

```{r mRNA-Data}
# Common genotypes
genos <- readRDS("./data/processed/common_genotypes.RDS")
dent <- as.character(genos$Dent$mrna)
flint <- as.character(genos$Flint$mrna)

# mRNA
mrna <- readRDS("./data/processed/subset_mrna_blues.RDS")[["100%"]]
mrna <- t(mrna)
mrna <- mrna[grep("Exp|Sigma", x = rownames(mrna), invert = TRUE), ]
mrna_df <- mrna %>%
  as_data_frame() %>%
  mutate(G = rownames(mrna)) %>%
  mutate(Group = ifelse(G %in% dent, yes = "Dent", no = "Flint"),
         Group = as.factor(Group)) %>%
  select(-G)
```

Run a principal component analysis (PCA) on the "raw" mRNA-BLUEs.
```{r Raw-PCA}
mrna_df %>%
  split(.$Group) %>%
  map(~select(-Group)) %>%
  str()
  map(prcomp)
  by_slice(.f = prcomp)
  map(~ prcomp, data = .)
pca_obj <- prcomp(mrna)
perc_var <- pca_obj$sd ^ 2 / sum(pca_obj$sd ^ 2) * 100
perc_var[1:3]
```

`r sum(perc_var[seq_len(3)])`% of the variance in the "raw" mRNA-BLUEs is 
explained by the first three principal components.



## Data pre-processing
Pre-process the data in the following order:

1.    Near-zero-variance filtering.
2.    Box-Cox tranformation
3.    Centering
4.    Scaling
```{r Transform-Data}
trans <- preProcess(mrna, 
                    method = c("BoxCox", "center", "scale", "nzv"))
# Apply the transformation
mrna_trans <- predict(trans, mrna)
#correlations <- cor(mrna_trans)
#high_corr <- findCorrelation(correlations, cutoff = 0.9)
#mrna_trans <- mrna_trans[, -high_corr]

# PCA
trans_pca_obj <- prcomp(mrna_trans)
trans_perc_var <- trans_pca_obj$sd ^ 2 / sum(trans_pca_obj$sd ^ 2) * 100
trans_perc_var[1:3]
```

`r sum(trans_perc_var[seq_len(3)])`% of the variance in the transformed 
mRNA-BLUEs is explained by the first three principal components compared to
`r sum(perc_var[seq_len(3)])`% in the "raw" data.




## Tidy-up data
```{r Tidy-Data}
mrna_lst <- list(Raw = mrna, Trans = mrna_trans)
mrna_lst[] <- lapply(mrna_lst, FUN = as.data.frame)
tidy_mrna <- mrna_lst %>%
  bind_rows(.id = "Type") %>%
  as_tibble() %>%
  gather(key = "mRNA", value = "Expression", -Type) %>%
  mutate(Type = as.factor(Type))
```


Compute the skewness and the Shapiro-Wilk test of normality for each mRNA
```{r Check-Normality}
mrna_skew <- tidy_mrna %>%
  group_by(Type, mRNA) %>%
  summarize(Skewness = e1071::skewness(Expression),
            Shapiro = stats::shapiro.test(Expression)$statistic)
```


Plot the distribution of skewness values across all mRNAs
```{r}
mrna_skew %>%
  ggplot(aes(x = Skewness, fill = Type)) +
  geom_density(alpha = 0.2) +
  theme(legend.position = "top")

mrna_skew %>%
  ggplot(aes(x = Skewness, fill = Type)) +
  xlim(c(-2, 2)) +
  geom_density(alpha = 0.2) +
  theme(legend.position = "top")
```

Find the least skewed/non-normally distributed mRNAs.
```{r Association-Shapiro-Wilks-Skewness}
mrna_skew %>%
  mutate(Abs_Skewness = abs(Skewness)) %>%
  ggplot(aes(x = Shapiro, y = Abs_Skewness)) +
  xlim(c(0.8, 1)) +
  ylim(c(0, 2)) +
  geom_point() +
  facet_grid(. ~ Type) +
  xlab("Shapiro-Wilks Test Statistic") +
  ylab("Absolute Skewness")
```




## Function for the imputation of a single mRNA.
```{r Impute-mRNA-Function}
## Function for the imputation of a single mRNA
impute_one_mrna <- function(x, y) {
  geno <- rownames(x)
  # Names of genotypes for which transcriptomic records exist
  nm2 <- rownames(y)
  # Names of genotypes for which transcriptomic records are missing.
  nm1 <- setdiff(rownames(x), nm2)
  # Hybrid parents not in y.
  geno1 <- geno[geno %in% nm1]
  # Hybrid parents in y.
  geno2 <- geno[geno %in% nm2]
  x <- x[match(unique(geno), rownames(x)), ]
  # Design matrix mapping GCA effects from genotypes with transcriptomic
  # records to y2.
  Z2 <- Matrix::sparse.model.matrix(~-1 + factor(geno2),
                                    drop.unused.levels = FALSE)
  colnames(Z2) <- gsub("factor\\(geno2\\)", replacement = "", x = colnames(Z2))
  Z2 <- Z2[, match(nm2, colnames(Z2))]
  rownames(Z2) <- geno2
  # Hybrid parents not in y.
  geno1 <- geno[geno %in% nm1]
  # Hybrid parents in y.
  geno2 <- geno[geno %in% nm2]
  x <- x[match(unique(geno), rownames(x)), ]
  y <- y[nm2, ]
  M2 <- y[, matrixStats::colVars(y) != 0]
  x <- x[, matrixStats::colVars(x) != 0]
  A <- build_kernel(M = x, lambda = 0.01, algorithm = "RadenII")
  A11 <- A[nm1, nm1, drop = FALSE]
  A12 <- A[nm1, nm2, drop = FALSE]
  A21 <- A[nm2, nm1, drop = FALSE]
  A22 <- A[nm2, nm2, drop = FALSE]
  Ainv <- solve(A)
  dimnames(Ainv) <- dimnames(A)
  A_up11 <- Ainv[nm1, nm1]
  A_up12 <- Ainv[nm1, nm2]
  # Eq.21
  M1 <- A12 %*% solve(A22) %*% M2
  J2 <- matrix(-1, nrow = ncol(A12), ncol = 1)
  # Eq.22
  J1 <- A12 %*% solve(A22) %*% J2
  # Eq.10
  epsilon <- t(chol(solve(Ainv[nm1, nm1])))
  # Eq.20
  W2 <- Z2 %*% M2
  w1 <- A12 %*% solve(A22) %*% Z2 %*% M2
  as.numeric(w1)
}
```


Plot the distribution of correlations between vectors of original and imputed
mRNAs.
```{r Correlation-Imputed-vs-NonImputed}
#imp_mrna <- vapply(seq_len(nrow(y)), FUN = function(i) {
#  z <- y[-i, ]
#  imp_mrna <- impute_one_mrna(x, z)
#  cor(y[i, ], imp_mrna)
#}, FUN.VALUE = numeric(1))
#hist(imp_mrna)
```